{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { objectEquals } from \"./utils\";\n\ntype ast = (TypeDeclaration | Expression)[];\n\ntype TypeParameterDeclaration = {\n    name: string;\n    defaultValue?: Expression;\n};\n\ntype TypeDeclaration = {\n    __typename: \"TypeDeclaration\";\n    name: string;\n    parameters: TypeParameterDeclaration[];\n    definition: Expression;\n};\n\n// TODO: keep track of referenced variables?\n\ntype CallExpression = {\n    __typename: \"CallExpression\";\n    callee: string;\n    parameters: Expression[]\n};\n\ntype NumberLiteralExpression = {\n    __typename: \"NumberLiteralExpression\";\n    value: number;\n};\n\ntype ItemLiteralExpression = {\n    __typename: \"ItemLiteralExpression\";\n};\n\ntype AbortLiteralExpression = {\n    __typename: \"AbortLiteralExpression\"\n}\n\ntype ArrayLiteralExpression = {\n    __typename: \"ArrayLiteralExpression\";\n    items: (Expression | _SpreadExpression)[]\n};\n\ntype _SpreadExpression = {\n    __typename: \"SpreadExpression\";\n    value: Expression;\n};\n\ntype ConditionExpression = {\n    __typename: \"ConditionExpression\";\n    evaluatee: Expression;\n    condition: Expression | _ExtendsExpression;\n    true: Expression;\n    false: Expression;\n}\n\ntype _InferExpression = {\n    __typename: \"InferExpression\";\n    spread: boolean;\n    name: string;\n};\n\ntype _ExtendsExpression = {\n    __typename: \"ExtendsExpression\"\n    items: (Expression | _InferExpression | _SpreadExpression)[];\n};\n\ntype ParameterReferenceExpression = {\n    __typename: \"ParameterReferenceExpression\",\n    name: string;\n}\n\nfunction evalAst(ast: ast) {\n    return ast.filter(item => item.__typename !== \"TypeDeclaration\").map((e) => normalizeItem(evalExpression(e as Expression, ast, {})));\n}\n\ntype Expression = CallExpression | NumberLiteralExpression | ItemLiteralExpression | ArrayLiteralExpression | ConditionExpression | ParameterReferenceExpression | AbortLiteralExpression;\n\ntype InternalItem = {\n    __typename: \"Item\"\n} | {\n    // Numbers could be represented by an array of items (that's how they are user-facing) but it's more efficient to do it this way\n    __typename: \"Number\",\n    length: number\n} | InternalItem[];\n\nfunction normalizeItem(i: InternalItem): InternalItem {\n    if(Array.isArray(i)) {\n        if(i.reduce((acc, cur) => acc && (!Array.isArray(cur) && cur.__typename === \"Item\"), true)) {\n            return {\n                __typename: \"Number\",\n                length: i.length\n            };\n        }\n        else {\n            return i.map(normalizeItem);\n        }\n    }\n    else {\n        return i;\n    }\n}\n\nfunction evalExpression(e: Expression, ast: ast, values: {\n    [key: string]: InternalItem\n}): InternalItem {\n    switch(e.__typename) {\n        case \"CallExpression\": {\n            // TODO: make sure that optional parameters are at the end\n            const def = ast.find(item => item.__typename === \"TypeDeclaration\" && item.name === e.callee) as TypeDeclaration | undefined;\n            if(!def) {\n                throw new Error(`Type definition with name ${e.callee} not found`);\n            }\n            return evalExpression(def.definition, ast, Object.fromEntries(def.parameters.map(\n                (parameter, index) => {\n                    if(e.parameters[index]) {\n                        return [parameter.name, evalExpression(e.parameters[index], ast, values)];\n                    }\n                    else if(parameter.defaultValue) {\n                        return [parameter.name, evalExpression(parameter.defaultValue, ast, {})];\n                    }\n                    else {\n                        throw new Error(`No value passed for parameter ${parameter.name} when calling type ${def.name}`);\n                    }\n                }\n            )));\n        }\n        case \"NumberLiteralExpression\": {\n            return {\n                __typename: \"Number\",\n                length: e.value\n            };\n        }\n        case \"ItemLiteralExpression\": {\n            return {\n                __typename: \"Item\"\n            };\n        }\n        case \"ArrayLiteralExpression\": {\n            const val: InternalItem = [];\n            for(const item of e.items) {\n                if(item.__typename === \"SpreadExpression\") {\n                    const res = evalExpression(item.value, ast, values);\n                    if(Array.isArray(res)) {\n                        res.forEach(i => val.push(i));\n                    }\n                    else if(res.__typename === \"Item\") {\n                        throw new Error(\"Cannot spread an item into an array\");\n                    }\n                    else if(res.__typename === \"Number\") {\n                        // TODO: make more efficient\n                        for(let i = 0; i < res.length; i++) {\n                            val.push({\n                                __typename: \"Item\"\n                            });\n                        }\n                    }\n                }\n                else {\n                    val.push(evalExpression(item, ast, values));\n                }\n            }\n            return val;\n        }\n        case \"ConditionExpression\": {\n            // Evaluate the extends thing\n            if(e.condition.__typename === \"ExtendsExpression\") {\n                // It's inferring things\n                // Helpful function\n                const fail = () => evalExpression(e.false, ast, values);\n                // Start off by evaluating the evaluatee and making sure it's the right type\n                // It has to be an array, it can't be just a number or item\n                let normalizedEvaluatee = normalizeItem(evalExpression(e.evaluatee, ast, values));\n                if(!Array.isArray(normalizedEvaluatee)) {\n                    if(normalizedEvaluatee.__typename === \"Item\") {\n                        return fail();\n                    }\n                    else {\n                        normalizedEvaluatee = Array(normalizedEvaluatee.length).fill({\n                            __typename: \"Item\"\n                        });\n                    }\n                }\n\n                // Evaluate all the expressions in the array except for the infers\n                // It's easiest to do this by splitting it up into separate arrays of non-infer items, evaluating each, then merging them\n                const items: ((Expression | _SpreadExpression)[] | _InferExpression)[] = [];\n                let activeArray: (Expression | _SpreadExpression)[] = [];\n                e.condition.items.forEach(item => {\n                    if(item.__typename === \"InferExpression\") {\n                        items.push(activeArray);\n                        activeArray = [];\n                        items.push(item);\n                    }\n                    else {\n                        activeArray.push(item);\n                    }\n                });\n                if(activeArray.length > 0) {\n                    items.push(activeArray);\n                }\n                const evaledItems = items.map(item => {\n                    if(Array.isArray(item)) {\n                        return normalizeItem(evalExpression({\n                            __typename: \"ArrayLiteralExpression\",\n                            items: item\n                        }, ast, values));\n                    }\n                    else {\n                        return item;\n                    }\n                });\n                // Flatten it\n                const flattened: (InternalItem | _InferExpression)[] = [];\n                evaledItems.forEach(item => {\n                    if(Array.isArray(item)) {\n                        item.forEach(i => flattened.push(i));\n                    }\n                    else {\n                        if(item.__typename === \"Number\") {\n                            for(let i = 0; i < item.length; i++) flattened.push({\n                                __typename: \"Item\"\n                            });\n                        }\n                        else {\n                            flattened.push(item);\n                        }\n                    }\n                });\n\n                // Now, we're in one of two scenarios:\n                // 1. There's no spread infer. This means that the array is of fixed length, so we can just compare all the items\n                // 2. There is a spread infer. Make sure that the array is at least the length of flattened minus the spread infer, then start evaluating from the front until we reach the spread infer, then go from the back\n                // These use a lot of the same code so I'll combine the two\n                const inferredValues: {\n                    [key: string]: InternalItem\n                } = {};\n                const containsSpreadInfer = flattened.reduce((acc, cur) => acc || (!Array.isArray(cur) && cur.__typename === \"InferExpression\" && cur.spread), false);\n                if(containsSpreadInfer ? (normalizedEvaluatee.length < flattened.length - 1) : (flattened.length !== normalizedEvaluatee.length)) {\n                    return fail();\n                }\n                let spreadInferRangeStart: number | undefined = undefined;\n                for(let i = 0; i < flattened.length; i++) {\n                    const flattenedItem = flattened[i];\n                    if(!Array.isArray(flattenedItem) && flattenedItem.__typename === \"InferExpression\") {\n                        if(flattenedItem.spread) {\n                            spreadInferRangeStart = i;\n                            break;\n                        }\n                        else {\n                            values[flattenedItem.name] = normalizedEvaluatee[i];\n                        }\n                    }\n                    else if(!objectEquals(flattenedItem, normalizedEvaluatee[i])) {\n                        return fail();\n                    }\n                }\n                if(containsSpreadInfer) {\n                    for(let i = normalizedEvaluatee.length - 1, j = flattened.length - 1;; i--, j--) {\n                        const flattenedItem = flattened[j];\n                        if(!Array.isArray(flattenedItem) && flattenedItem.__typename === \"InferExpression\") {\n                            if(flattenedItem.spread) {\n                                inferredValues[flattenedItem.name] = normalizedEvaluatee.slice(spreadInferRangeStart, i + 1);\n                                break;\n                            }\n                            else {\n                                values[flattenedItem.name] = normalizedEvaluatee[i];\n                            }\n                        }\n                        else if(!objectEquals(flattenedItem, normalizedEvaluatee[i])) {\n                            return fail();\n                        }\n                    }\n                }\n                return evalExpression(e.true, ast, {\n                    ...values,\n                    ...inferredValues\n                });\n            }\n            else {\n                // It's a bit easier\n                const res = normalizeItem(evalExpression(e.condition, ast, values));\n                const normalizedEvaluatee = normalizeItem(evalExpression(e.evaluatee, ast, values));\n                console.log(e[objectEquals(res, normalizedEvaluatee) ? \"true\" : \"false\"]);\n\n                return evalExpression(e[objectEquals(res, normalizedEvaluatee) ? \"true\" : \"false\"], ast, values)\n            }\n        }\n        case \"ParameterReferenceExpression\": {\n            return values[e.name];\n        }\n        case \"AbortLiteralExpression\": {\n            throw new Error(\"Exiting due to abort keyword\");\n        }\n    }\n}\n\nconst testDoc: ast = [\n    {\n        __typename: \"TypeDeclaration\",\n        name: \"Add\",\n        parameters: [\n            {\n                name: \"N1\"\n            },\n            {\n                name: \"N2\"\n            }\n        ],\n        definition: {\n            __typename: \"ArrayLiteralExpression\",\n            items: [\n                {\n                    __typename: \"SpreadExpression\",\n                    value: {\n                        __typename: \"ParameterReferenceExpression\",\n                        name: \"N1\"\n                    }\n                },\n                {\n                    __typename: \"SpreadExpression\",\n                    value: {\n                        __typename: \"ParameterReferenceExpression\",\n                        name: \"N2\"\n                    }\n                }\n            ]\n        }\n    },\n    {\n        __typename: \"TypeDeclaration\",\n        name: \"Subtract\",\n        parameters: [\n            {\n                name: \"N1\"\n            },\n            {\n                name: \"N2\"\n            }\n        ],\n        definition: {\n            __typename: \"ConditionExpression\",\n            evaluatee: {\n                __typename: \"ParameterReferenceExpression\",\n                name: \"N1\"\n            },\n            condition: {\n                __typename: \"ExtendsExpression\",\n                items: [\n                    {\n                        __typename: \"InferExpression\",\n                        spread: true,\n                        name: \"Result\"\n                    },\n                    {\n                        __typename: \"ParameterReferenceExpression\",\n                        name: \"N2\"\n                    }\n                ]\n            },\n            true: {\n                __typename: \"ParameterReferenceExpression\",\n                name: \"Result\"\n            },\n            false: {\n                __typename: \"AbortLiteralExpression\"\n            }\n        }\n    },\n    {\n        __typename: \"TypeDeclaration\",\n        name: \"Multiply\",\n        parameters: [\n            {\n                name: \"N1\"\n            },\n            {\n                name: \"N2\"\n            },\n            {\n                name: \"T\",\n                defaultValue: {\n                    __typename: \"ArrayLiteralExpression\",\n                    items: []\n                }\n            }\n        ],\n        definition: {\n            __typename: \"ConditionExpression\",\n            evaluatee: {\n                __typename: \"ParameterReferenceExpression\",\n                name: \"N2\"\n            },\n            condition: {\n                __typename: \"NumberLiteralExpression\",\n                value: 0\n            },\n            true: {\n                __typename: \"CallExpression\",\n                callee: \"Flatten\",\n                parameters: [\n                    {\n                        __typename: \"ParameterReferenceExpression\",\n                        name: \"T\"\n                    }\n                ]\n            },\n            false: {\n                __typename: \"CallExpression\",\n                callee: \"Multiply\",\n                parameters: [\n                    {\n                        __typename: \"ParameterReferenceExpression\",\n                        name: \"N1\"\n                    },\n                    {\n                        __typename: \"CallExpression\",\n                        callee: \"Subtract\",\n                        parameters: [\n                            {\n                                __typename: \"ParameterReferenceExpression\",\n                                name: \"N2\"\n                            },\n                            {\n                                __typename: \"NumberLiteralExpression\",\n                                value: 1\n                            }\n                        ]\n                    },\n                    {\n                        __typename: \"ArrayLiteralExpression\",\n                        items: [\n                            {\n                                __typename: \"ParameterReferenceExpression\",\n                                name: \"N1\"\n                            },\n                            {\n                                __typename: \"SpreadExpression\",\n                                value: {\n                                    __typename: \"ParameterReferenceExpression\",\n                                    name: \"T\"\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n    },\n    {\n        __typename: \"TypeDeclaration\",\n        name: \"Flatten\",\n        parameters: [\n            {\n                name: \"Input\"\n            }\n        ],\n        definition: {\n            __typename: \"ConditionExpression\",\n            evaluatee: {\n                __typename: \"ParameterReferenceExpression\",\n                name: \"Input\"\n            },\n            condition: {\n                __typename: \"ExtendsExpression\",\n                items: [\n                    {\n                        __typename: \"InferExpression\",\n                        spread: false,\n                        name: \"A\"\n                    },\n                    {\n                        __typename: \"InferExpression\",\n                        spread: false,\n                        name: \"B\"\n                    },\n                    {\n                        __typename: \"InferExpression\",\n                        spread: true,\n                        name: \"rest\"\n                    }\n                ]\n            },\n            true: {\n                __typename: \"ArrayLiteralExpression\",\n                items: [\n                    {\n                        __typename: \"CallExpression\",\n                        callee: \"Add\",\n                        parameters: [\n                            {\n                                __typename: \"ParameterReferenceExpression\",\n                                name: \"A\"\n                            },\n                            {\n                                __typename: \"ParameterReferenceExpression\",\n                                name: \"B\"\n                            }\n                        ]\n                    },\n                    {\n                        __typename: \"SpreadExpression\",\n                        value: {\n                            __typename: \"ParameterReferenceExpression\",\n                            name: \"rest\"\n                        }\n                    }\n                ]\n            },\n            false: {\n                __typename: \"ParameterReferenceExpression\",\n                name: \"Input\"\n            }\n        }\n    },\n    /*{\n        __typename: \"CallExpression\",\n        callee: \"Multiply\",\n        parameters: [\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 5\n            },\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 4\n            }\n        ]\n    },*/\n    {\n        __typename: \"CallExpression\",\n        callee: \"Add\",\n        parameters: [\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 5\n            },\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 8\n            }\n        ]\n    },\n    {\n        __typename: \"CallExpression\",\n        callee: \"Subtract\",\n        parameters: [\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 5\n            },\n            {\n                __typename: \"NumberLiteralExpression\",\n                value: 2\n            }\n        ]\n    }\n]\n\nconsole.log(evalAst(testDoc));"]}