type Add<N1, N2> = [...N1, ...N2];
type At<Array, Position> = Array extends [skip Position, infer Item, ...infer] ? Item : abort;
type Subtract<N1, N2> = N1 extends [...N2, ...infer Result] ? Result : [_, Subtract<N2, N1>];
type AbsoluteValue<Input> = Input extends [_, infer Number] ? Number : Input;
type EnsurePositive<Input> = Input extends [_, infer] ? abort : Input;
type Multiply<N1, N2, Result = 0> = N2 extends 0 ? Result : Multiply<N1, Subtract<N2, 1>, Add<Result, N1>>;
type True<> = 1;
type False<> = 0;
type IsLessThan<N1, N2> = N1 extends [...N2, ...infer] ? False<> : True<>;
type Divide<N1, N2, Result = 0> = IsLessThan<N1, N2> extends True<> ? [Result, N1] : Divide<Subtract<N1, N2>, N2, Add<Result, 1>>;
type Modulo<N1, N2> = At<Divide<N1, N2>, 1>;
type IsEven<N> = Modulo<N, 2> extends 0 ? True<> : False<>;
type IsOdd<N> = Modulo<N, 2> extends 0 ? False<> : True<>;

type Fibonacci<N, Result = 0> = N extends 0 ? Result : N extends 1 ? 1 : Add<Fibonacci<Subtract<N, 1>>, Fibonacci<Subtract<N, 2>>>;
type FibonacciSequenceUpTo<N, Result = []> = N extends 0 ? Result : FibonacciSequenceUpTo<Subtract<N, 1>, [Fibonacci<N>, ...Result]>;

type Pow<N1, N2, Result = 1> = N2 extends 0 ? Result : Multiply<N1, Pow<N1, Subtract<N2, 1>, Result>>;
type Factorial<N, Result = 1> = N extends 0 ? Result : Multiply<N, Factorial<Subtract<N, 1>>>;