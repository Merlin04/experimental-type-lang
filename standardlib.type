// Standard library

type Add<N1, N2> = [...N1, ...N2];
type At<Array, Position> = Array extends [skip Position, infer Item, ...infer] ? Item : abort(Array index out of bounds);
type Subtract<N1, N2> = N1 extends [...N2, ...infer Result] ? Result : [_, Subtract<N2, N1>];
type AbsoluteValue<Input> = Input extends [_, infer Number] ? Number : Input;
type EnsurePositive<Input> = Input extends [_, infer] ? abort(Value is not positive) : Input;
type Multiply<N1, N2, Result = 0> = N2 extends 0 ? Result : Multiply<N1, Subtract<N2, 1>, Add<Result, N1>>;
type True<> = 1;
type False<> = 0;
type IsLessThan<N1, N2> = N1 extends [...N2, ...infer] ? False<> : True<>;
type IsLessThanOrEq<N1, N2> = IsLessThan<Subtract<N1, 1>, N2>;
type Divide<N1, N2, Result = 0> = IsLessThan<N1, N2> extends True<> ? [Result, N1] : Divide<Subtract<N1, N2>, N2, Add<Result, 1>>;
type Modulo<N1, N2> = At<Divide<N1, N2>, 1>;
type IsEven<N> = Modulo<N, 2> extends 0 ? True<> : False<>;
type IsOdd<N> = Modulo<N, 2> extends 0 ? False<> : True<>;
type Pow<N1, N2, Result = 1> = N2 extends 0 ? Result : Multiply<N1, Pow<N1, Subtract<N2, 1>, Result>>;
type Factorial<N, Result = 1> = N extends 0 ? Result : Multiply<N, Factorial<Subtract<N, 1>>>;

type Fibonacci<N, Result = 0> = N extends 0 ? Result : N extends 1 ? 1 : Add<Fibonacci<Subtract<N, 1>>, Fibonacci<Subtract<N, 2>>>;
type FibonacciSequenceUpTo<N, Result = []> = N extends 0 ? Result : FibonacciSequenceUpTo<Subtract<N, 1>, [Fibonacci<N>, ...Result]>;

// Since we can't do floating point math, we'll just use a binary search and abort if the number isn't a perfect square.
// Based off of method 2 from https://www.geeksforgeeks.org/check-if-a-number-is-perfect-square-without-finding-square-root/
type Sqrt<N, Left = 1, Right = N> = IsLessThanOrEq<Left, Right> extends False<> ? abort(Number is not perfect square)
    : At<Divide<Add<Left, Right>, 2>, 0> extends [...infer Mid]
        ? Multiply<Mid, Mid> extends [...infer M]
            ? M extends N ? Mid : IsLessThan<M, N> extends True<> ? Sqrt<N, Add<Mid, 1>, Right> : Sqrt<N, Left, Subtract<Mid, 1>>
            : abort
        : abort;

// Test cases for the standard library
FibonacciSequenceUpTo<10>;
Sqrt<25>;
Add<[1, 2, 3], [4, 5, 6]>;
Subtract<[1, 2, 3], [4, 5, 6]>;
Multiply<5, 8>;